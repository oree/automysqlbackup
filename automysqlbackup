#!/usr/bin/env bash
#
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#=====================================================================
# USE AT OWN RISK
#=====================================================================
#
# I take no resposibility for any data loss or corruption when using
# this script..
# This script will not help in the event of a hard drive crash. If a 
# copy of the backup has not be stored offline or on another PC..
# You should copy your backups offline regularly for best protection.
#
# Happy backing up...
#
#=====================================================================
# Usage
#=====================================================================
#
# Add a file to your cron.daily folder like this one:
# 
# #!/bin/sh
# /usr/local/bin/automysqlbackup /etc/automysqlbackup/mysql_server1.conf
# /usr/local/bin/automysqlbackup /etc/automysqlbackup/mysql_server2.conf
# chown root.root /var/backup/db* -R
# find /var/backup/db* -type f -exec chmod 400 {} \;
# find /var/backup/db* -type d -exec chmod 700 {} \;
#
#
# If you don't supply an argument for automysqlbackup, the default configuration
# in this file will be used unless a global file CONFIGFILE exists.
#
# You can just copy the supplied automysqlbackup.conf as many times as you want
# and use for separate configurations, i.e. mysql servers.
#
#=====================================================================
# Backup Rotation
#=====================================================================
#
# Daily Backups are rotated weekly..
# Weekly Backups are run by default on Saturday Morning when
# cron.daily scripts are run...Can be changed with DOWEEKLY setting..
# Weekly Backups are rotated on a 5 week cycle..
# Monthly Backups are run on the 1st of the month..
# Monthly Backups are rotated on a 5 month cycle...
# It may be a good idea to copy Monthly backups offline or to another
# server..
#
#=====================================================================
# Restoring
#=====================================================================
# Firstly you will need to uncompress the backup file.
# eg.
# gunzip file.gz (or bunzip2 file.bz2)
#
# Next you will need to use the mysql client to restore the DB from the
# sql file.
# eg.
# mysql --user=username --pass=password --host=dbserver database < /path/file.sql
# or
# mysql --user=username --pass=password --host=dbserver -e "source /path/file.sql" database
#
# NOTE: Make sure you use "<" and not ">" in the above command because
# you are piping the file.sql to mysql and not the other way around.
#
#
#=====================================================================
#=====================================================================
#=====================================================================
#
#=====================================================================
# Change Log
#=====================================================================
#
# version 3.0_beta2 - (2011-08-21)
#     - Added possibility to backup local files. 
#     - Added full schema backup.
#     - Added master-data option.
#     - Fixed some bugs.
# version 3.0_beta1 - (2011-08-15)
#     - REMOVED: Implementation of Variables containing full path to binaries to
#       avoid possibly confusion with aliases or builtins. (by Johannes Kolter)
#       Inside a bash script no aliases are used! This didn't make ANY sense!
#       Thereby resolved bug item #3074425.
#     - Changed some variables to be arrays, i.e. lists, and removed the ugly
#       sed stuff.
#       Fixed bug item #3169562
#     - Added check for weekly and monthly backups, so that they are unique per day.
#       bug item #3185389
#     - Changed SHEBANG to #!/usr/bin/env bash  for portability reasons.
#       bug item #3292873
#     - Changed config file structure: read /etc/automysqlbackup/mysqlbackup.conf,
#       if supplied read configfile parameter (no more -c or sth. like that, just
#       the name of the file!),
#       whatever isn't set yet, set in here to default values.
#     - bug item #3110715: create a file in /etc/cron.d/daily and call the script
#       from in there, i.e. place the script in /usr/local/bin
#     - bug item #3082899: the PATH variables are different in ssh, you have to
#       supply the complete path
#     - Fixed bug item #3064547, suggestion accepted.
#     - Fixed bug item #3031023, suggestion accepted.
#     - Fixed bug item #3030604, resolved due to design correction.
#     - Fixed bug item #3025849, as long as basename is in $PATH on your system.
#     - Fixed bug item #3030478.
#     - bug item #3054633: .muttrc entry save=yes will result in saving sent files!
#     - Feature request item #1538588.
#     - Feature request item #1538138.
#     - Feature request item #1538142.
#     - Feature request item #1541843 was already included.
#     - Feature request item #2808012.
#     - Feature request item #2831465.
#     - Feature request item #3052484. Mysqldump already has an ssl option.
#     - Feature request item #3190079. I hope cleaning up everything older than 24
#       hours as a lower limit is good enough.
#     - Feature request item #3284779 was already included. See CONFIG_mysql_dump_latest.
#     - Feature request item #3053623.
# version 2.6.0 - (2011-07-19)
#     - Fixed bug where files would not email correctly (Fix by Jesse Vaughan)
#     - Added section to encrypt .gz and .bz2 files using openssl (added by Jesse Vaughan)
# version 2.5.1-01 - (2010-07-06)
#     - Fixed pathname bug item #3025849 (by Johannes Kolter)
# version 2.5.1 - (2010-07-04)
#     - Added support for default and optional config file (by Johannes Kolter)
#     - Rotating after backup was successful whith find(1) (by Johannes Kolter)
#     - Implementation of Variables containing full path to binaries to
#       avoid possibly confusion with aliases or builtins. (by Johannes Kolter)
#     - Fixed bug where weekly backups were not being rotated.
#       Added rotation of 5 monthly backups
#       Now all old backups are deleted, not only the most recent one
#       (inspired by oleg@bintime.com)
#     - Use Debian special-file to access database (by Johannes Kolter)
#     - Fixed bug ID: 1438565
#       Moved IO redirection to a place before decicions are made and actions are taken.
#       (inspired by Derk Bernhardt)
#     - Fixed bug ID: #3000316 (reported by Sascha Feldhorst)
#     - Fixed bug ID: #1529458 (reported by Natalie ( njwood ))
#     - Fixed bug ID: #1548919 (reported by Piotr Kuczynski)
# version 2.5 - (2006-01-15)
#		Added support for setting MAXIMUM_PACKET_SIZE and CONFIG_mysql_dump_socket parameters (suggested by Yvo van Doorn)
# version 2.4 - (2006-01-23)
#    Fixed bug where weekly backups were not being rotated. (Fix by wolf02)
#    Added hour an min to backup filename for the case where backups are taken multiple
#    times in a day. NOTE This is not complete support for mutiple executions of the script
#    in a single day.
#    Added MAILCONTENT="quiet" option, see docs for details. (requested by snowsam)
#    Updated path statment for compatibility with OSX.
#    Added "CONFIG_mysql_dump_latest" to additionally store the last backup to a standard location. (request by Grant29)
# version 2.3 - (2005-11-07)
#    Better error handling and notification of errors (a long time coming)
#    Compression on Backup server to MySQL server communications. 
# version 2.2 - (2004-12-05)
#    Changed from using depricated "-N" to "--skip-column-names".
#    Added ability to have compressed backup's emailed out. (code from Thomas Heiserowski)
#    Added maximum attachment size setting.
# version 2.1 - (2004-11-04)
#    Fixed a bug in daily rotation when not using gzip compression. (Fix by Rob Rosenfeld)
# version 2.0 - (2004-07-28)
#    Switched to using IO redirection instead of pipeing the output to the logfile.
#    Added choice of compression of backups being gzip of bzip2.
#    Switched to using functions to facilitate more functionality.
#    Added option of either gzip or bzip2 compression. 
# version 1.10 - (2004-07-17)
#    Another fix for spaces in the paths (fix by Thomas von Eyben)
#    Fixed bug when using PREBACKUP and POSTBACKUP commands containing many arguments.
# version 1.9 - (2004-05-25)
#    Small bug fix to handle spaces in LOGFILE path which contains spaces (reported by Thomas von Eyben)
#    Updated docs to mention that Log email can be sent to multiple email addresses.
# version 1.8 - (2004-05-01)
#    Added option to make backups restorable to alternate database names
#    meaning that a copy of the database can be created (Based on patch by Rene Hoffmann)
#    Seperated options into standard and advanced.
#    Removed " from single file dump DBMANES because it caused an error but
#    this means that if DB's have spaces in the name they will not dump when CONFIG_mysql_dump_use_separate_dirs=no.
#    Added -p option to mkdir commands to create multiple subdirs without error.
#    Added disk usage and location to the bottom of the backup report.
# version 1.7 - (2004-04-22)
#    Fixed an issue where weelky backups would only work correctly if server
#    locale was set to English (issue reported by Tom Ingberg)
#    used "eval" for "rm" commands to try and resolve rotation issues.
#    Changed name of status log so multiple scripts can be run at the same time.
# version 1.6 - (2004-03-14)
#   Added PREBACKUP and POSTBACKUP command functions. (patch by markpustjens)
#   Added support for backing up DB's with Spaces in the name.
#   (patch by markpustjens)
# version 1.5 - (2004-02-24)
#   Added the ability to exclude DB's when the "all" option is used.
#   (Patch by kampftitan)
# version 1.4 - (2004-02-02)
#   Project moved to Sourceforge.net
# version 1.3 - (2003-09-25)
#   Added support for backing up "all" databases on the server without
#    having to list each one seperately in the configuration.
#   Added DB restore instructions.
# version 1.2 - (2003-03-16)
#   Added server name to the backup log so logs from multiple servers
#   can be easily identified.
# version 1.1 - (2003-03-13)
#   Small Bug fix in monthly report. (Thanks Stoyanski)
#   Added option to email log to any email address. (Inspired by Stoyanski)
#   Changed Standard file name to .sh extention.
#   Option are set using yes and no rather than 1 or 0.
# version 1.0 - (2003-01-30)
#   Added the ability to have all databases backup to a single dump
#   file or seperate directory and file for each database.
#   Output is better for log keeping.
# version 0.6 - (2003-01-22)
#   Bug fix for daily directory (Added in version 0.5) rotation.
# version 0.5 - (2003-01-20)
#   Added "daily" directory for daily backups for neatness (suggestion by Jason)
#   Added CONFIG_mysql_dump_host option to allow backing up a remote server (Suggestion by Jason)
#   Added "--quote-names" option to mysqldump command.
#   Bug fix for handling the last and first of the year week rotation.
# version 0.4 - (2002-11-06)
#   Added the abaility for the script to create its own directory structure.
# version 0.3 - (2002-10-01)
#   Changed Naming of Weekly backups so they will show in order.
# version 0.2 - (2002-09-27)
#   Corrected weekly rotation logic to handle weeks 0 - 10 
# version 0.1 - (2002-09-21)
#   Initial Release
#
#=====================================================================
#=====================================================================
#=====================================================================
#
# Should not need to be modified from here down!!
#
#=====================================================================
#=====================================================================
#=====================================================================

world_param="$1"

###################################################################################
# Functions


# info		Called when one of the signals EXIT, SIGHUP, SIGINT, SIGQUIT or SIGTERM is emitted.
#		It removes the IO redirection, mails any log file information and cleans up any temporary files.
# args		(none)
# return	(none)
mail_cleanup () {
  removeIO
  # if the variables $log_file and $log_errfile aren't set or are empty and both associated files don't exist, skip output methods.
  # this might happen if 'exit' occurs before they are set.
  if [[ ! -e "$log_file" && ! -e "$log_errfile" ]];then
    echo "Skipping normal output methods, since the program exited before any log files could be created."
  else
    case "${CONFIG_mailcontent}" in
	    'files')
			    # Include error log if larger than zero.
			    if [[ -s "$log_errfile" ]]; then
				    backupfiles="${backupfiles} $log_errfile"
				    errornote="WARNING: Error Reported - "
			    fi
			    # Get backup size
			    attsize=`du -c ${backupfiles} | awk 'END {print $1}'`
			    if (( ${CONFIG_mail_maxattsize} >= ${attsize} )); then
				    backupfiles=`echo "${backupfiles}" | sed -e "s# # -a #g"`	#enable multiple attachments
				    mutt -s "${errornote} MySQL Backup Log and SQL Files for ${CONFIG_mysql_dump_host} - ${datetimestamp}" ${backupfiles} ${CONFIG_mail_address} < "$log_file"
			    else
				    cat "$log_file" | mail -s "WARNING! - MySQL Backup exceeds set maximum attachment size on ${CONFIG_mysql_dump_host} - ${datetimestamp}" ${CONFIG_mail_address}
			    fi
			    ;;
	    'log')
			    cat "$log_file" | mail -s "MySQL Backup Log for ${CONFIG_mysql_dump_host} - ${datetimestamp}" ${CONFIG_mail_address}
			    [[ -s "$log_errfile" ]] && cat "$log_errfile" | mail -s "ERRORS REPORTED: MySQL Backup error Log for ${CONFIG_mysql_dump_host} - ${datetimestamp}" ${CONFIG_mail_address}
			    ;;
	    'quiet')
			    if [[ -s "$log_errfile" ]]; then
					    cat "$log_errfile" | mail -s "ERRORS REPORTED: MySQL Backup error Log for ${CONFIG_mysql_dump_host} - ${datetimestamp}" ${CONFIG_mail_address}
					    cat "$log_file" | mail -s "MySQL Backup Log for ${CONFIG_mysql_dump_host} - ${datetimestamp}" ${CONFIG_mail_address}
			    fi
			    ;;
	    *)
			    if [[ -s "$log_errfile" ]]; then
					    cat "$log_file"
					    echo
					    echo "###### WARNING ######"
					    echo "Errors reported during AutoMySQLBackup execution.. Backup failed"
					    echo "Error log below.."
					    cat "$log_errfile"
			    else
				  cat "$log_file"
			    fi
			    ;;
    esac
    ###################################################################################
    # Clean up and finish
    [[ -e "$log_file" ]] && rm -f "$log_file"
    [[ -e "$log_errfile" ]] && rm -f "$log_errfile"
  fi
}

# info	Converts a floating point number to an integer, i.e. removing all decimal places.
# args	floating point number
floor () {
  echo "$1/1" | bc
}

# info	Converts a floating point number to an integer, i.e. removing all decimal places, and adds 1.
# args	floating point number
ceil  () {
  echo "define ceil (x) {if (x<0) {return x/1} \
         else {if (scale(x)==0) {return x} \
         else {return x/1 + 1 }}} ; ceil($1)" | bc;
}

# info	Calculate the logarithm of a floating point number with base 2.
# args	floating point number
log_base2 () {
  echo "l($1)/l(2)" | bc -l
}

# info	Checks if a folder is writable by creating a temporary file in it and removing it afterwards.
# args	folder to test
# return	returns false if creation of temporary file failed or it can't be removed afterwards; else true
chk_folder_writable () {
  local temp
  temp=$(mktemp $1/tmp.XXXXXX)
  if (( $? == 0 )); then
    rm "${temp}" || return 1
    return 0
  else
    return 1
  fi
}

# info	When called, sets error and notify strings matching their flags. It then goes through all collected error and notify messages and displays them.
# args	(none)
# return	true if no errors were set, otherwise false
error_handler () {

  errors=(
    [0x01]='dbdump() failed.'
    [0x02]='Backup of local files failed. This is not this scripts primary objective. Continuing anyway.'
    [0x04]="Could not create the backup_dir ${CONFIG_backup_dir}. Please check permissions of the higher directory."
    [0x08]='At least one of the subdirectories (daily, weekly, monthly, latest) failed to create.'
    [0x10]="The backup_dir ${CONFIG_backup_dir} is not writable AND/OR executable."
    [0x20]='Could not remove the cleartext file after encryption. This error did not cause an abort. Remove it manually and check permissions.'
    [0x40]='Encryption failed. Continuing without encryption.'
    [0x80]='The mysql server is empty, i.e. no databases found. Check if something is wrong. Exiting.'
    [0x100]='Failed to create the named pipe (fifo) for reading in all databases. Exiting.'
    [0x200]='Dependency programs are missing. Perhaps they are not in $PATH. Exiting.'
    [0x400]='No basedir found, i.e. '
    [0x800]="${CONFIG_backup_dir} is not writable. Exiting."
    [0x1000]=''
    [0x2000]=''
  )

  notify=(
    [0x01]="${CONFIG_configfile} was not found - no global config file."
    [0x02]="Parsed config file ${world_param}."
    [0x04]="Unreadable config file \"${world_param}\""
    [0x08]='Supplied more than one argument, ignoring ALL arguments - using default and global config file only.'
    [0x10]='Could not remove the files in the latest directory. Please check this.'
    [0x20]='No local backup files were set.'
    [0x40]=''
    [0x80]=''
    [0x100]=''
    [0x200]=''
    [0x400]=''
    [0x800]=''
    [0x1000]=''
    [0x2000]=''
  )

  local temp
  while (( $N > 0 )); do
    temp=$((2**$(floor $(log_base2 $N))))
    echo "Note:" ${notify[$temp]}
    let "N-=$temp"
  done
  if (( $E > 0 )); then
    while (( $E > 0 )); do
      temp=$((2**$(floor $(log_base2 $E))))
      echo "Error:" ${errors[$temp]}
      let "E-=$temp"
    done
    exit 1
  else
    exit 0
  fi
}

# info	Uses mysqldump to backup data from database. If compression option is set, piping data through gzip or bzip2.
# args	file to save data to
dbdump () {
  local var1="$1"
  shift 1
  if (( $CONFIG_dryrun )); then
    case "${CONFIG_mysql_dump_compression}" in
	'gzip')
	  echo "dry-running: mysqldump --user=${CONFIG_mysql_dump_username} --password=${CONFIG_mysql_dump_password} --host=${CONFIG_mysql_dump_host} ${opt[@]} $@ | gzip > ${var1}${suffix};"
	  ;;
	'bzip2')
	  echo "dry-running: mysqldump --user=${CONFIG_mysql_dump_username} --password=${CONFIG_mysql_dump_password} --host=${CONFIG_mysql_dump_host} ${opt[@]} $@ | bzip2 > ${var1}${suffix};"
	  ;;
	*)
	  echo "dry-running: mysqldump --user=${CONFIG_mysql_dump_username} --password=${CONFIG_mysql_dump_password} --host=${CONFIG_mysql_dump_host} ${opt[@]} $@ > ${var1}${suffix};"
	  ;;
    esac
    return 0;
  else
    case "${CONFIG_mysql_dump_compression}" in
	'gzip')
	  mysqldump --user="${CONFIG_mysql_dump_username}" --password="${CONFIG_mysql_dump_password}" --host="${CONFIG_mysql_dump_host}" "${opt[@]}" "$@" | gzip > "${var1}${suffix}";
	  return $?
	  ;;
	'bzip2')
	  mysqldump --user="${CONFIG_mysql_dump_username}" --password="${CONFIG_mysql_dump_password}" --host="${CONFIG_mysql_dump_host}" "${opt[@]}" "$@" | bzip2 > "${var1}${suffix}";
	  return $?
	  ;;
	*)
	  mysqldump --user="${CONFIG_mysql_dump_username}" --password="${CONFIG_mysql_dump_password}" --host="${CONFIG_mysql_dump_host}" "${opt[@]}" "$@" > "${var1}${suffix}";
	  return $?
	  ;;
    esac
  fi
}


# info	Packs files in array ${#CONFIG_backup_local_files[@]} into tar file with optional compression.
# args	archive file without compression suffix, i.e. ending on .tar
# return	true in case of dry-run, otherwise the return value of tar -cvf
backup_local_files () {
  if ((! ${#CONFIG_backup_local_files[@]})) ; then
    if (( $CONFIG_dryrun )); then
      case "${CONFIG_mysql_dump_compression}" in
	  'gzip')
	    echo "tar -czvf ${1}${suffix} ${CONFIG_backup_local_files[@]}";
	    ;;
	  'bzip2')
	    echo "tar -cjvf ${1}${suffix} ${CONFIG_backup_local_files[@]}";
	    ;;
	  *)
	    echo "tar -cvf ${1}${suffix} ${CONFIG_backup_local_files[@]}";
	    ;;
      esac
      echo "dry-running: tar -cv ${1} ${CONFIG_backup_local_files[@]}"
      return 0;
    else
      case "${CONFIG_mysql_dump_compression}" in
	  'gzip')
	    tar -czvf "${1}${suffix}" "${CONFIG_backup_local_files[@]}";
	    return $?
	    ;;
	  'bzip2')
	    tar -cjvf "${1}${suffix}" "${CONFIG_backup_local_files[@]}";
	    return $?
	    ;;
	  *)
	    tar -cvf "${1}${suffix}" "${CONFIG_backup_local_files[@]}";
	    return $?
	    ;;
      esac
    fi
  else
    let "N |= $N_backup_local_nofiles"
    echo "No local backup files specified."
  fi
}

# info	Backs up the database schema.
# args	filename to save data to
# return	true in case of dry-run, otherwise the return value of mysqldump
fullschema () {
  if (( $CONFIG_dryrun )); then
    case "${CONFIG_mysql_dump_compression}" in
	'gzip')
	  echo "dry-running: mysqldump --user=${CONFIG_mysql_dump_username} --password=${CONFIG_mysql_dump_password} --host=${CONFIG_mysql_dump_host} ${opt_fullschema[@]} | gzip > ${1}${suffix}";
	  ;;
	'bzip2')
	  echo "dry-running: mysqldump --user=${CONFIG_mysql_dump_username} --password=${CONFIG_mysql_dump_password} --host=${CONFIG_mysql_dump_host} ${opt_fullschema[@]} | bzip2 > ${1}${suffix}";
	  ;;
	*)
	  echo "dry-running: mysqldump --user=${CONFIG_mysql_dump_username} --password=${CONFIG_mysql_dump_password} --host=${CONFIG_mysql_dump_host} ${opt_fullschema[@]} > ${1}${suffix}";
	  ;;
    esac
    return 0;
  else
    case "${CONFIG_mysql_dump_compression}" in
	'gzip')
	  mysqldump --user="${CONFIG_mysql_dump_username}" --password="${CONFIG_mysql_dump_password}" --host="${CONFIG_mysql_dump_host}" "${opt_fullschema[@]}" | gzip > "${1}${suffix}";
	  return $?
	  ;;
	'bzip2')
	  mysqldump --user="${CONFIG_mysql_dump_username}" --password="${CONFIG_mysql_dump_password}" --host="${CONFIG_mysql_dump_host}" "${opt_fullschema[@]}" | bzip2 > "${1}${suffix}";
	  return $?
	  ;;
	*)
	  mysqldump --user="${CONFIG_mysql_dump_username}" --password="${CONFIG_mysql_dump_password}" --host="${CONFIG_mysql_dump_host}" "${opt_fullschema[@]}" > "${1}${suffix}";
	  return $?
	  ;;
    esac
  fi
}

# info	This function is called after data has already been saved. It performs encryption and hardlink-copying of files to a
#		latest folder.
files_postprocessing () {
	local flags
	let "flags=0x00"
	let "flags_files_postprocessing_success_encrypt=0x01"
	
	# -> CONFIG_encrypt
	[[ "${CONFIG_encrypt}" = "yes" && "${CONFIG_encrypt_password}" ]] && {
	  if (( $CONFIG_dryrun )); then
	    printf 'dry-running: openssl enc -aes-256-cbc -e -in %s%s -out %s.enc%s -pass pass:%s\n' ${1} ${suffix} ${1} ${suffix} "${CONFIG_encrypt_password}"
	  else
	    openssl enc -aes-256-cbc -e -in ${1}${suffix} -out ${1}.enc${suffix} -pass pass:"${CONFIG_encrypt_password}"
	    if (( $? == 0 )); then
		  if rm ${1}${suffix} 2>&1; then
		    echo "Successfully encrypted archive as ${1}.enc${suffix}"
		    let "flags |= $flags_files_postprocessing_success_encrypt"
		  else
		    echo "Successfully encrypted archive as ${1}.enc${suffix}, but could not remove cleartext file ${1}${suffix}."
		    let "E |= $E_enc_cleartext_delfailed"
		  fi
	    else
		  let "E |= $E_enc_failed"
	    fi
	  fi
	}
	# <- CONFIG_encrypt

	# -> CONFIG_mysql_dump_latest
	[[ "${CONFIG_mysql_dump_latest}" = "yes" ]] && {
	  if (( $flags & $flags_files_postprocessing_success_encrypt )); then
		if (( $CONFIG_dryrun )); then
		  printf 'dry-running: cp -al %s.enc%s %s/latest/\n' "${1}" "${suffix}" "${CONFIG_backup_dir}"
		else
		  cp -al "${1}".enc"${suffix}" "${CONFIG_backup_dir}"/latest/
		fi
	  else
		if (( $CONFIG_dryrun )); then
		  printf 'dry-running: cp -al %s%s %s/latest/\n' "${1}" "${suffix}" "${CONFIG_backup_dir}"
		else
		  cp -al "${1}${suffix}" "${CONFIG_backup_dir}"/latest/
		fi
	  fi
	}
	# <- CONFIG_mysql_dump_latest

	return $flags
}

# return	true, if variable is set; else false
isSet() {
  if [[ ! ${!1} && ${!1-_} ]]; then return 1; else return 0; fi
}

# return	true, if variable is empty; else false
isEmpty() {
  if [[ ${!1} ]]; then return 1; else return 0; fi
}				# return true if empty, else false

# info	Save stdout and stderr 
activateIO() {
  ###################################################################################
  # IO redirection for logging.
  # $1 = $log_file, $2 = $log_errfile

  #(( $CONFIG_debug )) || {
    touch "$log_file"
    exec 6>&1				# Link file descriptor #6 with stdout. Saves stdout.
    exec > "$log_file"		# stdout replaced with file $log_file.

    touch "$log_errfile"
    exec 7>&2				# Link file descriptor #7 with stderr. Saves stderr.
    exec 2> "$log_errfile"	# stderr replaced with file $log_errfile.
  #}
}

# info	Restore stdout and stderr redirections.
removeIO() {
  exec 1>&6 6>&-      # Restore stdout and close file descriptor #6.
  exec 2>&7 7>&-      # Restore stdout and close file descriptor #7.
}

# info	Default configuration options.
default_config() {
  CONFIG_configfile="/etc/automysqlbackup/automysqlbackup.conf"
  CONFIG_backup_dir='/var/backup/db'

  CONFIG_do_monthly="01"
  CONFIG_do_weekly="5"

  CONFIG_rotation_daily=6
  CONFIG_rotation_weekly=35
  CONFIG_rotation_monthly=150

  CONFIG_mysql_dump_port=3306
  CONFIG_mysql_dump_usessl='yes'
  CONFIG_mysql_dump_username='root'
  CONFIG_mysql_dump_password=''
  CONFIG_mysql_dump_host='localhost'
  CONFIG_mysql_dump_socket=''
  CONFIG_mysql_dump_create_database='no'
  CONFIG_mysql_dump_use_separate_dirs='yes'
  CONFIG_mysql_dump_compression='gzip'
  CONFIG_mysql_dump_commcomp='no'
  CONFIG_mysql_dump_latest='no'
  CONFIG_mysql_dump_max_allowed_packet=''
  CONFIG_mysql_dump_single_transaction='no'
  CONFIG_mysql_dump_master_data=
  CONFIG_mysql_dump_full_schema='yes'

  CONFIG_backup_local_files=()

  CONFIG_db_names=()
  CONFIG_db_month_names=()
  CONFIG_db_exclude=( 'information_schema' )
  CONFIG_table_exclude=()

  CONFIG_mailcontent='stdout'
  CONFIG_mail_maxattsize=4000
  CONFIG_mail_address='root'

  CONFIG_encrypt='no'
  CONFIG_encrypt_password='password0123'

  # dry-run, i.e. show what you are gonna do without actually doing it
  # inactive: =0 or commented out
  # active: uncommented AND =1
  #CONFIG_dryrun=1
  # for developers only, note: uninitialized variable is false, (( $uninitialized_var )) = false, (( 1 )) = true, does not work with [ ] or [[ ]] tests
  #CONFIG_debug=1

}

# info	Put associated texts inside the error handler function, so that the used variables are
# 		set as late as possible. This is important when dealing with occurences of the error_handler
# 		before all config files are processed - the texts include variables set in the config files.
# args	(none)
errors_notifies() {
  let "E=0x00" # no errors
  let "N=0x00" # no notifications

  let "E_dbdump_failed=0x01"
  let "E_backup_local_failed=0x02"
  let "E_mkdir_basedir_failed=0x04"
  let "E_mkdir_subdirs_failed=0x08"
  let "E_perm_basedir=0x10"
  let "E_enc_cleartext_delfailed=0x20"
  let "E_enc_failed=0x40"
  let "E_db_empty=0x80"
  let "E_create_pipe_failed=0x100"
  let "E_missing_deps=0x200"
  let "E_no_basedir=0x400"
  let "E_config_backupdir_not_writable=0x800"

  let "N_config_file_missing=0x01"
  let "N_arg_conffile_parsed=0x02"
  let "N_arg_conffile_unreadable=0x04"
  let "N_too_many_args=0x08"
  let "N_latest_cleanup_failed=0x10"
  let "N_backup_local_nofiles=0x20"
}

# info	Checks directories and subdirectories for existence and activates logging to either
#		$CONFIG_backup_dir or /tmp depending on what exists.
# args	(none)
directory_checks_enable_logging () {
    ###################################################################################
    # Check directories and do cleanup work

    checkdirs=( "${CONFIG_backup_dir}"/{daily,weekly,monthly,latest} )
    [[ "${CONFIG_backup_local_files[@]}" ]] && { checkdirs=( "${checkdirs[@]}" "${CONFIG_backup_dir}/backup_local_files" ); }
    [[ "${CONFIG_mysql_dump_full_schema}" = 'yes' ]] && { checkdirs=( "${checkdirs[@]}" "${CONFIG_backup_dir}/fullschema" ); }

    tmp_permcheck=0
    printf '# Checking for permissions to write to folders:\n'


    # "dirname ${CONFIG_backup_dir}" exists?
    # Y -> ${CONFIG_backup_dir} exists?
    #      Y -> Dry-run?
    #           Y -> log to /tmp, proceed to test subdirs
    #           N -> check writable ${CONFIG_backup_dir}?
    #                Y -> proceed to test subdirs
    #                N -> error: can't write to ${CONFIG_backup_dir}. Exit.
    #      N -> Dry-run?
    #           N -> proceed without testing subdirs
    #           Y -> create directory ${CONFIG_backup_dir}?
    #                Y -> check writable ${CONFIG_backup_dir}?
    #                     Y -> proceed to test subdirs
    #                     N -> error: can't write to ${CONFIG_backup_dir}. Exit.
    #                N -> error: ${CONFIG_backup_dir} is not writable. Exit.
    # N -> Dry-run?
    #      Y -> log to /tmp, proceed without testing subdirs
    #      N -> error: no basedir. Exit.


    # -> check base folder
    printf 'base folder %s ... ' "$(dirname ${CONFIG_backup_dir})"
    if [[ -d "$(dirname ${CONFIG_backup_dir})" ]]; then

	printf 'exists ... ok.\n'
	printf 'backup folder %s ... ' "${CONFIG_backup_dir}"

	if [[ -d "${CONFIG_backup_dir}" ]]; then
	    printf 'exists ... writable? ' 
	    if (( $CONFIG_dryrun )); then
	      printf 'dry-running. Skipping. Logging to /tmp\n'
	      log_file="/tmp/${CONFIG_mysql_dump_host}-`date +%N`.log"
	      log_errfile="/tmp/ERRORS_${CONFIG_mysql_dump_host}-`date +%N`.log"
	      activateIO "$log_file" "$log_errfile"
	      tmp_permcheck=1
	    else
		if chk_folder_writable "${CONFIG_backup_dir}"; then
		  printf 'yes. Proceeding.\n'
		  log_file="${CONFIG_backup_dir}/${CONFIG_mysql_dump_host}-`date +%N`.log"
		  log_errfile="${CONFIG_backup_dir}/ERRORS_${CONFIG_mysql_dump_host}-`date +%N`.log"
		  activateIO "$log_file" "$log_errfile"
		  tmp_permcheck=1
		else
		  printf 'no. Exiting.\n'
		  let "E |= $E_config_backupdir_not_writable"
		  error_handler
		fi
	    fi

	else

	    printf 'creating ... '
	    if (( $CONFIG_dryrun )); then
		printf 'dry-running. Skipping.\n'
	    else
		if mkdir -p "${CONFIG_backup_dir}" >/dev/null 2>&1; then
		  printf 'success.\n'
		  log_file="${CONFIG_backup_dir}/${CONFIG_mysql_dump_host}-`date +%N`.log"
		  log_errfile="${CONFIG_backup_dir}/ERRORS_${CONFIG_mysql_dump_host}-`date +%N`.log"
		  activateIO "$log_file" "$log_errfile"
		  tmp_permcheck=1
		else
		  printf 'failed. Exiting.\n'
		  let "E |= $E_mkdir_basedir_failed"
		  error_handler
		fi
	    fi

	fi

    else

	if (( $CONFIG_dryrun )); then
	    printf 'dry-running. Skipping. Logging to /tmp\n'
	    log_file="/tmp/${CONFIG_mysql_dump_host}-`date +%N`.log"
	    log_errfile="/tmp/ERRORS_${CONFIG_mysql_dump_host}-`date +%N`.log"
	    activateIO "$log_file" "$log_errfile"
	else
	  printf 'does not exist. Exiting.\n'
	  let "E |= $E_no_basedir"
	  error_handler
	fi

    fi
    # <- check base folder


    # -> check subdirs
    if (( $tmp_permcheck ==  1 )); then

	(( $CONFIG_dryrun )) || [[ -r "${CONFIG_backup_dir}" && -x "${CONFIG_backup_dir}" ]] || { let "E |= $E_perm_basedir"; error_handler; }

	for i in "${checkdirs[@]}"; do
	  printf 'checking directory "%s" ... ' "$i"
	  if [[ -d "$i" ]]; then
	    printf 'exists.\n'
	  else
	    printf 'creating ... '
	    if (( $CONFIG_dryrun )); then
	      printf 'dry-running. Skipping.\n'
	    else
		if mkdir -p "$i" >/dev/null 2>&1; then
		  printf 'success.\n'
		else
		  printf 'failed. Exiting.\n'
		  let "E |= $E_mkdir_subdirs_failed"
		  error_handler
		fi
	    fi
	  fi
	done

    fi
    # <- check subdirs

}

# info	If CONFIG_mysql_dump_latest is set to 'yes', the directory ${CONFIG_backup_dir}"/latest will be cleaned.
# args	(none)
latest_cleanup ()  {
    # -> latest cleanup
    if [[ "${CONFIG_mysql_dump_latest}" = "yes" ]]; then
      printf 'Cleaning up latest directory ... '
      if (( $CONFIG_dryrun )); then
	printf 'dry-running. Skipping.\n'
      else
	if rm -f "${CONFIG_backup_dir}"/latest/* >/dev/null 2>&1; then
	  printf 'success.\n'
	else
	  printf 'failed. Continuing anyway, activating Note-Flag.\n'
	  let "N |= $N_latest_cleanup_failed"
	fi
      fi
    fi
    # <- latest cleanup
}

# info	Checks for dependencies in form of external programs, that need to be available when running this program.
#		This depends on the options set in the configuration.
# args	(none)
dependency_check () {
    echo
    echo "# Testing for installed programs"
    dependencies=( 'mysql' 'mysqldump' )
    [[ "x$CONFIG_mysql_dump_compression" = 'xbzip2' ]] && dependencies=( "${dependencies[@]}" 'bzip2' )
    [[ "x$CONFIG_mysql_dump_compression" = 'xgzip' ]] && dependencies=( "${dependencies[@]}" 'gzip' )
    if [[ "x$CONFIG_mailcontent" = 'xlog' || "x$CONFIG_mailcontent" = 'xquiet' ]]; then
      dependencies=( "${dependencies[@]}" 'mail' )
    elif [[ "x$CONFIG_mailcontent" = 'xfiles' ]]; then
      dependencies=( "${dependencies[@]}" 'mail' 'mutt' )
    fi
    for i in "${dependencies[@]}"; do
      printf '%s ... ' "$i"
      if hash "$i" 2>&-; then
	printf 'found.\n'
      else
	printf 'not found. Aborting.\n';
	let "E |= $E_missing_deps"
	error_handler
      fi
    done
    echo
}

# info	Parses the configuration options and sets the variables appropriately.
# args	(none)
parse_configuration () {
    # OPT string for use with mysqldump ( see man mysqldump )
    opt=( '--quote-names' '--opt' )

    # OPT string for use with mysql (see man mysql )
    mysql_opt=()

    # OPT string for use with mysqldump fullschema
    opt_fullschema=( '--all-databases' '--routines' '--no-data' )

    [[ "${CONFIG_mysql_dump_usessl}" = "yes" ]] 		&& {
	opt=( "${opt[@]}" '--ssl' )
	mysql_opt=( "${mysql_opt[@]}" '--ssl' )
	opt_fullschema=( "${opt_fullschema[@]}" '--ssl' )
    }
    [[ "${CONFIG_mysql_dump_master_data}" ]] && (( ${CONFIG_mysql_dump_master_data} == 1 || ${CONFIG_mysql_dump_master_data} == 2 )) && { opt=( "${opt[@]}" "--master-data=${CONFIG_mysql_dump_master_data}" );}
    [[ "${CONFIG_mysql_dump_single_transaction}" = "yes" ]]	&& {
	opt=( "${opt[@]}" '--single-transaction' )
	opt_fullschema=( "${opt_fullschema[@]}" '--single-transaction' )
    }
    [[ "${CONFIG_mysql_dump_commcomp}" = "yes" ]]		&& {
	opt=( "${opt[@]}" '--compress' )
	opt_fullschema=( "${opt_fullschema[@]}" '--compress' )
    }
    [[ "${CONFIG_mysql_dump_max_allowed_packet}" ]]		&& {
	opt=( "${opt[@]}" "--max_allowed_packet=${CONFIG_mysql_dump_max_allowed_packet}" )
	opt_fullschema=( "${opt_fullschema[@]}" "--max_allowed_packet=${CONFIG_mysql_dump_max_allowed_packet}" )
    }
    [[ "${CONFIG_mysql_dump_socket}" ]]			&& {
	opt=( "${opt[@]}" "--socket=${CONFIG_mysql_dump_socket}" )
	mysql_opt=( "${mysql_opt[@]}" "--socket=${CONFIG_mysql_dump_socket}" )
	opt_fullschema=( "${opt_fullschema[@]}" "--socket=${CONFIG_mysql_dump_socket}" )
    }
    [[ "${CONFIG_mysql_dump_port}" ]]			&& {
	opt=( "${opt[@]}" "--port=${CONFIG_mysql_dump_port}" )
	mysql_opt=( "${mysql_opt[@]}" "--port=${CONFIG_mysql_dump_port}" )
	opt_fullschema=( "${opt_fullschema[@]}" "--port=${CONFIG_mysql_dump_port}" )
    }

    # Check if CREATE DATABASE should be included in Dump
    if [[ "${CONFIG_mysql_dump_use_separate_dirs}" = "yes" ]]; then
	    if [[ "${CONFIG_mysql_dump_create_database}" = "no" ]]; then
		    opt=( "${opt[@]}" '--no-create-db' )
	    else
		    opt=( "${opt[@]}" '--databases' )
	    fi
    else
	    opt=( "${opt[@]}" '--databases' )
    fi

    if ((${#CONFIG_table_exclude[@]})); then
      for i in "${CONFIG_table_exclude[@]}"; do
	opt=( "${opt[@]}" "--ignore-table=$i" )
      done
    fi
      

    # -> determine suffix
    case "${CONFIG_mysql_dump_compression}" in
      'gzip')	suffix='.gz';;
      'bzip2')	suffix='.bz2';;
      *)		suffix='';;
    esac
    # <- determine suffix
}

# END __FUNCTIONS
#--------------------------------------------------------------------------------------------------------------------------------------
# BEGIN __STARTUP

default_config		# load default config
errors_notifies	# set error and notifier flags
trap mail_cleanup EXIT SIGHUP SIGINT SIGQUIT SIGTERM	# Set function mail_cleanup to be called upon SIGNAL event EXIT, SIGHUP, SIGINT, SIGQUIT or SIGTERM.
# info		read main configuration file $default['CONFIGFILE'],
#		only if it exists and is readable, overwrites previous definitions
if [[ -r "${CONFIG_configfile}" ]]; then source "${CONFIG_configfile}"; echo "Parsed config file \"${CONFIG_configfile}\""; else let "N |= $N_config_file_missing"; fi; echo
# info		parse parameter 'configfile', optional, overwrites previous definitions
if (( $# == 1 )); then if [[ -r "${world_param}" ]]; then source "${world_param}"; let "N |= $N_arg_conffile_parsed"; else let "N |= $N_arg_conffile_unreadable"; fi; else let "N |= $N_too_many_args"; fi
(( $CONFIG_dryrun )) && {
  echo "NOTE: We are dry-running. That means, that the script just shows you what it would do, if it were operating normally."
  echo "THE PRINTED COMMANDS CAN'T BE COPIED AND EXECUTED IF THERE ARE SPECIAL CHARACTERS, SPACES, ETC. IN THERE THAT WOULD NEED TO BE PROPERLY QUOTED IN ORDER TO WORK. THESE WERE CORRECTLY QUOTED FOR THE OUTPUT COMMAND, BUT CAN'T BE SEEN NOW."
  echo
}
directory_checks_enable_logging		# check directories for existence and start logging to either $CONFIG_backup_dir or /tmp
latest_cleanup				# cleanup the latest directory if $CONFIG_mysql_dump_latest is set to 'yes'


###################################################################################################################################
# Set environment variables

# Make sure that all messages are in the standard language, i.e. mostly english.
export LC_ALL=C
PROGNAME=`basename $0`
PATH=${PATH}:/usr/local/bin:/usr/bin:/bin:/usr/local/mysql/bin 
version=3.0							# Version Number

datetimestamp=`date +%Y-%m-%d_%Hh%Mm`				# Datestamp e.g 2002-09-21_18h12m
date_stamp=`date +%Y-%m-%d`					# Datestamp e.g 2002-09-21
date_day_of_week=`date +%A`					# Day of the week e.g. Monday
date_dayno_of_week=`date +%u`					# Day number of the week 1 to 7 where 1 represents Monday
date_day_of_month=`date +%e`					# Date of the Month e.g. 27
date_month=`date +%B`						# Month e.g January
date_weekno=`date +%V | sed -e 's/^0//'`						# Week Number e.g 37
date_lastday_of_last_month=`date -d "$(date -d "$(date +%Y-%m-%d) -1 month" +%Y-%m-01) +1 month -1 day" +%e`
date_lastday_of_this_month=`date -d "$(date -d "$(date +%Y-%m-%d) +1 month" +%Y-%m-01) -1 day" +%e`

backupfiles=""
###################################################################################################################################


dependency_check	# check for required programs
parse_configuration	# parse configuration and set variables appropriately




# END __STARTUP
#--------------------------------------------------------------------------------------------------------------------------------------
# BEGIN __PREPARE

# debug output of variables
(( $CONFIG_debug )) && { echo; echo "# DEBUG: printing all current variables"; declare -p | egrep -o '.* (CONFIG_[a-z_]*|opt|mysql_opt)=.*'; echo; }




# -> get all dbs from server

  # bash 4.x version
  #mapfile -t alldbnames < <(mysql --user="${CONFIG_mysql_dump_username}" --password="${CONFIG_mysql_dump_password}" --host="${CONFIG_mysql_dump_host}" --batch --skip-column-names -e "show databases")

  # POSIX
  if mkfifo mypipe; then
    mysql --user="${CONFIG_mysql_dump_username}" --password="${CONFIG_mysql_dump_password}" --host="${CONFIG_mysql_dump_host}" "${mysql_opt[@]}" --batch --skip-column-names -e "show databases" > mypipe &
    while read -r line;do
      alldbnames=( "${alldbnames[@]}" "$line" )
    done < mypipe
    rm mypipe
  else
    let "E |= $E_create_pipe_failed"
    error_handler
  fi

  # mkfifo foo || exit; trap 'rm -f foo' EXIT


  ((! "${#alldbnames[@]}" )) && { let "E |= $E_db_empty"; error_handler; }

# <- Get all DBs on the server


# -> remove excluded dbs from list
for exclude in "${CONFIG_db_exclude[@]}"; do
  for i in "${!alldbnames[@]}"; do if [[ "x${alldbnames[$i]}" = "x${exclude}" ]]; then unset 'alldbnames[i]'; fi; done
done
# <- remove excluded dbs from list


# check for empty array lists and copy all dbs
((! ${#CONFIG_db_names[@]}))	&& declare -a CONFIG_db_names=( "${alldbnames[@]}" )
((! ${#CONFIG_db_month_names[@]}))	&& declare -a CONFIG_db_month_names=( "${alldbnames[@]}" )


(( $CONFIG_debug )) && {
  echo "DEBUG: before pre-backup"
  ( IFS=,; echo "DEBUG: CONFIG_db_names '${CONFIG_db_names[*]}'" )
  ( IFS=,; echo "DEBUG: CONFIG_db_month_names '${CONFIG_db_month_names[*]}'" )
}


# END __PREPARE
#--------------------------------------------------------------------------------------------------------------------------------------
# BEGIN __MAIN


###################################################################################
# Run pre-backup commands, optional

if [[ "${CONFIG_prebackup}" ]]; then
	echo "======================================================================"
	echo "Prebackup command output."
	echo
	source ${CONFIG_prebackup}
	echo
	echo "======================================================================"
	echo
fi


###################################################################################
# Run pre-backup commands, optional

if [[ "${CONFIG_backup_local_files[@]}" ]] && [[ ${CONFIG_do_weekly} != 0 && ${date_dayno_of_week} = ${CONFIG_do_weekly} ]] && (shopt -s nullglob dotglob; f=("${CONFIG_backup_dir}/backup_local_files/bcf_weekly_${date_weekno}_${date_stamp}_"[0-9][0-9]"h"[0-9][0-9]"m.tar${suffix}"); ((! ${#f[@]}))); then
	echo "======================================================================"
	echo "Backup local files. Doing this weekly on CONFIG_do_weekly."
	echo
	backup_local_files "${CONFIG_backup_dir}/backup_local_files/bcf_weekly_${date_weekno}_${datetimestamp}.tar"
	tmp_flags=$?; var=; 
	if (( $? == 0 )); then
	  echo "success!"
	  backupfiles="${backupfiles} ${CONFIG_backup_dir}/backup_local_files/bcf_weekly_${date_weekno}_${datetimestamp}.tar"
	else
	  let "E |= $E_backup_local_failed"
	  echo "failed!"
	fi
	echo
	echo "======================================================================"
	echo
fi


### filename formats
##
## example date values:
# 14'th of August (08) 2011
# week number: 32
# Sunday (date_dayno_of_week: 7)
##
## separate db's:
#	monthly_DBNAME_August_2011-08-14_18h12m.sql(.enc).{gz,bzip2}
#	weekly_DBNAME_32_2011-08-14_18h12m.sql(.enc).{gz,bzip2}
#	daily_DBNAME_7_2011-08-14_18h12m.sql(.enc).{gz,bzip2}
## all-databases:
#	monthly_all-databases_DBNAME_August_2011-08-14_18h12m.sql(.enc).{gz,bzip2}
#	weekly_all-databases_DBNAME_32_2011-08-14_18h12m.sql(.enc).{gz,bzip2}
#	daily_all-databases_DBNAME_7_2011-08-14_18h12m.sql(.enc).{gz,bzip2}


echo "======================================================================"
echo "AutoMySQLBackup version ${version}"
echo "http://sourceforge.net/projects/automysqlbackup/"
echo 
echo "Backup of Database Server - ${CONFIG_mysql_dump_host}"
( IFS=,; echo "Databases - ${CONFIG_db_names[*]}" )
( IFS=,; echo "Databases (monthly) - ${CONFIG_db_month_names[*]}" )
echo "======================================================================"


# -> dump full schema
if [[ "${CONFIG_mysql_dump_full_schema}" = 'yes' ]]; then
	echo "======================================================================"
	echo "Dump full schema."
	echo

	# monthly
	if (( ${CONFIG_do_monthly} != 0 && (${date_day_of_month} == ${CONFIG_do_monthly} || $date_day_of_month == $date_lastday_of_this_month && $date_lastday_of_this_month < ${CONFIG_do_monthly}) )) && (shopt -s nullglob dotglob; f=("${CONFIG_backup_dir}/fullschema/fullschema_monthly_${date_month}_${date_stamp}_"[0-9][0-9]"h"[0-9][0-9]"m.sql${suffix}"); ((! ${#f[@]}))); then
	  fullschema "${CONFIG_backup_dir}/fullschema/fullschema_monthly_${date_month}_${datetimestamp}.sql"
	  if (( $? == 0 )); then
	    echo "Rotating $(( ${CONFIG_rotation_monthly}/31 )) month backups for ${mdb}"
	    if (( $CONFIG_dryrun )); then
	      find "${CONFIG_backup_dir}/fullschema" -mtime +"${CONFIG_rotation_monthly}" -type f -name 'fullschema_monthly*' -exec echo "dry-running: rm" {} \;
	    else
	      find "${CONFIG_backup_dir}/fullschema" -mtime +"${CONFIG_rotation_monthly}" -type f -name 'fullschema_monthly*' -exec rm {} \;
	    fi
	    files_postprocessing "${CONFIG_backup_dir}/fullschema/fullschema_monthly_${date_month}_${datetimestamp}.sql"
	    tmp_flags=$?; var=; (( $tmp_flags & $flags_files_postprocessing_success_encrypt )) && var=.enc
	    backupfiles="${backupfiles} ${CONFIG_backup_dir}/fullschema/fullschema_monthly_${date_month}_${datetimestamp}.sql${var}${suffix}"
	  else
	    let "E |= $E_dump_fullschema_failed"
	  fi
	fi

	# weekly
	if [[ ${CONFIG_do_weekly} != 0 && ${date_dayno_of_week} = ${CONFIG_do_weekly} ]] && (shopt -s nullglob dotglob; f=("${CONFIG_backup_dir}/fullschema/fullschema_weekly_${date_weekno}_${date_stamp}_"[0-9][0-9]"h"[0-9][0-9]"m.sql${suffix}"); ((! ${#f[@]}))); then
	  fullschema "${CONFIG_backup_dir}/fullschema/fullschema_weekly_${date_weekno}_${datetimestamp}.sql"
	  if (( $? == 0 )); then
	    echo "Rotating $(( ${CONFIG_rotation_monthly}/31 )) month backups for ${mdb}"
	    if (( $CONFIG_dryrun )); then
	      find "${CONFIG_backup_dir}/fullschema" -mtime +"${CONFIG_rotation_weekly}" -type f -name 'fullschema_weekly*' -exec echo "dry-running: rm" {} \;
	    else
	      find "${CONFIG_backup_dir}/fullschema" -mtime +"${CONFIG_rotation_weekly}" -type f -name 'fullschema_weekly*' -exec rm {} \;
	    fi
	    files_postprocessing "${CONFIG_backup_dir}/fullschema/fullschema_weekly_${date_weekno}_${datetimestamp}.sql"
	    tmp_flags=$?; var=; (( $tmp_flags & $flags_files_postprocessing_success_encrypt )) && var=.enc
	    backupfiles="${backupfiles} ${CONFIG_backup_dir}/fullschema/fullschema_weekly_${date_weekno}_${datetimestamp}.sql${var}${suffix}"
	  else
	    let "E |= $E_dump_fullschema_failed"
	  fi
	fi

	# daily
	fullschema "${CONFIG_backup_dir}/fullschema/fullschema_daily_${date_day_of_week}_${datetimestamp}.sql"
	if (( $? == 0 )); then
	  echo "Rotating $(( ${CONFIG_rotation_monthly}/31 )) month backups for ${mdb}"
	  if (( $CONFIG_dryrun )); then
	    find "${CONFIG_backup_dir}/fullschema" -mtime +"${CONFIG_rotation_daily}" -type f -name 'fullschema_daily*' -exec echo "dry-running: rm" {} \;
	  else
	    find "${CONFIG_backup_dir}/fullschema" -mtime +"${CONFIG_rotation_daily}" -type f -name 'fullschema_daily*' -exec rm {} \;
	  fi
	  files_postprocessing "${CONFIG_backup_dir}/fullschema/fullschema_daily_${date_day_of_week}_${datetimestamp}.sql"
	  tmp_flags=$?; var=; (( $tmp_flags & $flags_files_postprocessing_success_encrypt )) && var=.enc
	  backupfiles="${backupfiles} ${CONFIG_backup_dir}/fullschema/fullschema_daily_${date_day_of_week}_${datetimestamp}.sql${var}${suffix}"
	else
	  let "E |= $E_dump_fullschema_failed"
	fi
	echo
	echo "======================================================================"
	echo
  
fi
# <- dump full schema



# -> separate dir for each database
if [[ "${CONFIG_mysql_dump_use_separate_dirs}" = "yes" ]]; then
	
	echo "Separate-DBs Backup Start Time `date`"
	echo "======================================================================"
	
	# Monthly Backup of Databases, unique per month
	if (( ${CONFIG_do_monthly} != 0 && (${date_day_of_month} == ${CONFIG_do_monthly} || $date_day_of_month == $date_lastday_of_this_month && $date_lastday_of_this_month < ${CONFIG_do_monthly}) )); then

		for mdb in "${CONFIG_db_month_names[@]}"; do
			(shopt -s nullglob dotglob; f=("${CONFIG_backup_dir}/monthly/${mdb}/monthly_${mdb}_${date_month}_${date_stamp}_"[0-9][0-9]"h"[0-9][0-9]"m.sql${suffix}"); ((${#f[@]}))) && continue
			[[ -d "${CONFIG_backup_dir}/monthly/${mdb}" ]] || {
			  if (( $CONFIG_dryrun )); then
			    printf 'dry-running: mkdir -p %s/monthly/%s\n' "${CONFIG_backup_dir}" "${mdb}"
			  else
			    mkdir -p "${CONFIG_backup_dir}/monthly/${mdb}"
			  fi
			}
			echo "Monthly Backup of ${mdb}..."
			
			dbdump "${CONFIG_backup_dir}/monthly/${mdb}/monthly_${mdb}_${date_month}_${datetimestamp}.sql" "${mdb}"
			if (( $? == 0 )); then
				echo "Rotating $(( ${CONFIG_rotation_monthly}/31 )) month backups for ${mdb}"
				if (( $CONFIG_dryrun )); then
				  find "${CONFIG_backup_dir}/monthly/${mdb}" -mtime +"${CONFIG_rotation_monthly}" -type f -exec echo "dry-running: rm" {} \;
				else
				  find "${CONFIG_backup_dir}/monthly/${mdb}" -mtime +"${CONFIG_rotation_monthly}" -type f -exec rm {} \;
				fi
				files_postprocessing "${CONFIG_backup_dir}/monthly/${mdb}/monthly_${mdb}_${date_month}_${datetimestamp}.sql"
				tmp_flags=$?; var=; (( $tmp_flags & $flags_files_postprocessing_success_encrypt )) && var=.enc
				backupfiles="${backupfiles} ${CONFIG_backup_dir}/monthly/${mdb}/monthly_${mdb}_${date_month}_${datetimestamp}.sql${var}${suffix}"
			else
				let "E |= $E_dbdump_failed"
				echo "dbdump with parameters \"${CONFIG_db_names[@]}\" \"${CONFIG_backup_dir}/monthly/${mdb}/monthly_${mdb}_${date_month}_${datetimestamp}.sql\" failed!"
			fi

			echo ----------------------------------------------------------------------
		done
	fi

	for db in "${CONFIG_db_names[@]}"; do
		[[ -d "${CONFIG_backup_dir}/daily/${db}" ]]	|| mkdir -p "${CONFIG_backup_dir}/daily/${db}"
		[[ -d "${CONFIG_backup_dir}/weekly/${db}" ]]	|| mkdir -p "${CONFIG_backup_dir}/weekly/${db}"
		
		# Weekly Backup, unique per week
		if [[ ${CONFIG_do_weekly} != 0 && ${date_dayno_of_week} = ${CONFIG_do_weekly} ]] && (shopt -s nullglob dotglob; f=("${CONFIG_backup_dir}/weekly/${db}/weekly_${db}_${date_weekno}_${date_stamp}_"[0-9][0-9]"h"[0-9][0-9]"m.sql${suffix}"); ((! ${#f[@]}))); then
			echo "Weekly Backup of Database ( ${db} )"
			echo
			
			dbdump "${CONFIG_backup_dir}/weekly/${db}/weekly_${db}_${date_weekno}_${datetimestamp}.sql" "${db}"
			if (( $? == 0 )); then
				echo "Rotating $(( ${CONFIG_rotation_weekly}/7 )) weeks Backups..."
				if (( $CONFIG_dryrun )); then
				  find "${CONFIG_backup_dir}/weekly/${db}" -mtime +"${CONFIG_rotation_weekly}" -type f -exec echo "dry-running: rm" {} \;
				else
				  find "${CONFIG_backup_dir}/weekly/${db}" -mtime +"${CONFIG_rotation_weekly}" -type f -exec rm {} \;
				fi
				files_postprocessing "${CONFIG_backup_dir}/weekly/${db}/weekly_${db}_${date_weekno}_${datetimestamp}.sql"
				tmp_flags=$?; var=; (( $tmp_flags & $flags_files_postprocessing_success_encrypt )) && var=.enc
				backupfiles="${backupfiles} ${CONFIG_backup_dir}/weekly/${db}/weekly_${db}_${date_weekno}_${datetimestamp}.sql${var}${suffix}"
			else
				let "E |= $E_dbdump_failed"
				echo "dbdump with parameters \"${CONFIG_db_names[@]}\" \"${CONFIG_backup_dir}/weekly/${db}/weekly_${db}_${date_weekno}_${datetimestamp}.sql\" failed!"
			fi
			
			echo "----------------------------------------------------------------------"

		fi

		# Daily Backup
		echo "Daily Backup of Database ( ${db} )"
		echo
		
		dbdump "${CONFIG_backup_dir}/daily/${db}/daily_${db}_${date_day_of_week}_${datetimestamp}.sql" "${db}"
		if (( $? == 0 )); then
			echo "Rotating daily Backup..."
			if (( $CONFIG_dryrun )); then
			  find "${CONFIG_backup_dir}/daily/${db}" -mtime +"${CONFIG_rotation_daily}" -type f -exec echo "dry-running: rm" {} \;
			else
			  find "${CONFIG_backup_dir}/daily/${db}" -mtime +"${CONFIG_rotation_daily}" -type f -exec rm {} \;
			fi
			files_postprocessing "${CONFIG_backup_dir}/daily/${db}/daily_${db}_${date_day_of_week}_${datetimestamp}.sql"
			tmp_flags=$?; var=; (( $tmp_flags & $flags_files_postprocessing_success_encrypt )) && var=.enc
			backupfiles="${backupfiles} ${CONFIG_backup_dir}/daily/${db}/daily_${db}_${date_day_of_week}_${datetimestamp}.sql${var}${suffix}"
		else
			let "E |= $E_dbdump_failed"
			echo "dbdump with parameters \"${CONFIG_db_names[@]}\" \"${CONFIG_backup_dir}/daily/${db}/daily_${db}_${date_day_of_week}_${datetimestamp}.sql\" failed!"
		fi
		
		echo "----------------------------------------------------------------------"

	done
	
	echo "Backup End `date`"
	echo "======================================================================"

# <- separate dir for each database


# -> one backup file for all databases
else 

	echo "One-File Backup Start `date`"
	echo "======================================================================"
	# Monthly Full Backup of all Databases, unique per month
	if (( ${CONFIG_do_monthly} != 0 && (${date_day_of_month} == ${CONFIG_do_monthly} || $date_day_of_month == $date_lastday_of_this_month && $date_lastday_of_this_month < ${CONFIG_do_monthly}) )) && (shopt -s nullglob dotglob; f=("${CONFIG_backup_dir}/monthly/monthly_all-databases_${date_month}_${date_stamp}_"[0-9][0-9]"h"[0-9][0-9]"m.sql${suffix}"); ((! ${#f[@]}))); then
		echo "Monthly full Backup of ( ${CONFIG_db_month_names[@]} )..."
		  
		dbdump "${CONFIG_backup_dir}/monthly/monthly_all-databases_${date_month}_${datetimestamp}.sql" "${CONFIG_db_month_names[@]}"
		if (( $? == 0 )); then
			echo "Rotating $(( ${CONFIG_rotation_monthly}/31 )) month backups."
			if (( $CONFIG_dryrun )); then
			  find "${CONFIG_backup_dir}/monthly" -mtime +"${CONFIG_rotation_monthly}" -type f -exec echo "dry-running: rm" {} \;
			else
			  find "${CONFIG_backup_dir}/monthly" -mtime +"${CONFIG_rotation_monthly}" -type f -exec rm {} \;
			fi
			files_postprocessing "${CONFIG_backup_dir}/monthly/monthly_all-databases_${date_month}_${datetimestamp}.sql"
			tmp_flags=$?; var=; (( $tmp_flags & $flags_files_postprocessing_success_encrypt )) && var=.enc
			backupfiles="${backupfiles} ${CONFIG_backup_dir}/monthly/monthly_all-databases_${date_month}_${datetimestamp}.sql${var}${suffix}"
		else
			let "E |= $E_dbdump_failed"
			echo "dbdump with parameters \"${CONFIG_db_names[@]}\" \"${CONFIG_backup_dir}/monthly/monthly_all-databases_${date_month}_${datetimestamp}.sql\" failed!"
		fi
		
		echo "----------------------------------------------------------------------"
	fi
	
	# Weekly Backup, unique per week
	if [[ ${CONFIG_do_weekly} != 0 && "${date_dayno_of_week}" = "${CONFIG_do_weekly}" ]] && (shopt -s nullglob dotglob; f=("${CONFIG_backup_dir}/weekly/weekly_all-databases_${date_weekno}_${date_stamp}_"[0-9][0-9]"h"[0-9][0-9]"m.sql${suffix}"); ((! ${#f[@]}))); then
		echo "Weekly Backup of Databases ( ${CONFIG_db_names[@]} )"
		echo
		echo
		dbdump "${CONFIG_backup_dir}/weekly/weekly_all-databases_${date_weekno}_${datetimestamp}.sql" "${CONFIG_db_names[@]}"
		if (( $? == 0 )); then
			echo "Rotating $(( ${CONFIG_rotation_weekly}/7 )) weeks Backups..."
			if (( $CONFIG_dryrun )); then
			  find "${CONFIG_backup_dir}/weekly/" -mtime +"${CONFIG_rotation_weekly}" -type f -exec echo "dry-running: rm" {} \;
			else
			  find "${CONFIG_backup_dir}/weekly/" -mtime +"${CONFIG_rotation_weekly}" -type f -exec rm {} \;
			fi
			files_postprocessing "${CONFIG_backup_dir}/weekly/weekly_all-databases_${date_weekno}_${datetimestamp}.sql"
			tmp_flags=$?; var=; (( $tmp_flags & $flags_files_postprocessing_success_encrypt )) && var=.enc
			backupfiles="${backupfiles} ${CONFIG_backup_dir}/weekly/weekly_all-databases_${date_weekno}_${datetimestamp}.sql${var}${suffix}" 
		else
			let "E |= $E_dbdump_failed"
			echo "dbdump with parameters \"${CONFIG_db_names[@]}\" \"${CONFIG_backup_dir}/weekly/weekly_all-databases_${date_weekno}_${datetimestamp}.sql\" failed!"
		fi
		
		echo "----------------------------------------------------------------------"
	# Daily Backup, multiple per day possible
	else
		echo "Daily Backup of Databases ( ${CONFIG_db_names[@]} )"
		echo
		echo
			dbdump "${CONFIG_backup_dir}/daily/daily_all-databases_${date_day_of_week}_${datetimestamp}.sql" "${CONFIG_db_names[@]}"
			if (( $? == 0 )); then
				echo "Rotating daily Backup..."
				if (( $CONFIG_dryrun )); then
				  find "${CONFIG_backup_dir}/daily" -mtime +"${CONFIG_rotation_daily}" -type f -exec echo "dry-running: rm" {} \;
				else
				  find "${CONFIG_backup_dir}/daily" -mtime +"${CONFIG_rotation_daily}" -type f -exec rm {} \;
				fi
				files_postprocessing "${CONFIG_backup_dir}/daily/daily_all-databases_${date_day_of_week}_${datetimestamp}.sql"
				tmp_flags=$?; var=; (( $tmp_flags & $flags_files_postprocessing_success_encrypt )) && var=.enc
				backupfiles="${backupfiles} ${CONFIG_backup_dir}/daily/daily_all-databases_${date_day_of_week}_${datetimestamp}.sql${var}${suffix}"
			else
				let "E |= $E_dbdump_failed"
				echo "dbdump with parameters \"${CONFIG_db_names[@]}\" \"${CONFIG_backup_dir}/daily/daily_all-databases_${date_day_of_week}_${datetimestamp}.sql\" failed!"
			fi

		echo "----------------------------------------------------------------------"
	fi
	echo "Backup End Time `date`"
	echo "======================================================================"
	
fi
# <- one backup file for all databases


# -> finished information
echo "Total disk space used for backup storage..."
echo "Size - Location"
echo `du -hsD "${CONFIG_backup_dir}"`
echo
echo "======================================================================"
# <- finished information


###################################################################################
# Run post-backup commands, optional

if [[ "${CONFIG_postbackup}" ]];then
	echo "======================================================================"
	echo "Postbackup command output."
	echo
	source ${CONFIG_postbackup}
	echo
	echo "======================================================================"
fi


if [[ -s "$log_errfile" ]];then status=1; else status=0; fi

###################################################################################
# Mail results, invoked upon exit


exit ${status}
